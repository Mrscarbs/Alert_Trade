package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"

	"github.com/gin-gonic/gin"
)

const api_key = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1bmlxdWVfbmFtZSI6ImFsZXJ0dHJhZGUiLCJyb2xlIjoiQWRtaW4iLCJuYmYiOjE3MzAxMDgzNTQsImV4cCI6MTczMDk3MjM1NCwiaWF0IjoxNzMwMTA4MzU0LCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjUwMTkxIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1MDE5MSJ9.1kAR-vVgNgl1HYbexgQjqm0KXVzixZHVXJecoDasDSc"

type cashflow_quaterly_master struct {
	Success bool `json:"success"`
	Data    []struct {
		COLUMNNAME string  `json:"COLUMNNAME"`
		RID        int     `json:"RID"`
		Y202406    float64 `json:"Y202406"`
		Y202403    float64 `json:"Y202403"`
		Y202312    float64 `json:"Y202312"`
		Y202309    float64 `json:"Y202309"`
		Y202306    float64 `json:"Y202306"`
		Y202303    float64 `json:"Y202303"`
		Y202212    float64 `json:"Y202212"`
		Y202209    float64 `json:"Y202209"`
		Rowno      int     `json:"rowno"`
	} `json:"data"`
	Message string `json:"message"`
}

type pnl_struct struct {
	Success bool `json:"success"`
	Data    []struct {
		COLUMNNAME string  `json:"COLUMNNAME"`
		RID        int     `json:"RID"`
		Y202403    float64 `json:"Y202403"`
		Y202303    float64 `json:"Y202303"`
		Rowno      int     `json:"rowno"`
	} `json:"data"`
	Message string `json:"message"`
}
type Balancesheet struct {
	Success bool `json:"success"`
	Data    []struct {
		COLUMNNAME string  `json:"COLUMNNAME"`
		RID        int     `json:"RID"`
		Y202403    float64 `json:"Y202403"`
		Y202303    float64 `json:"Y202303"`
		Rowno      int     `json:"rowno"`
	} `json:"data"`
	Message string `json:"message"`
}
type shareholding struct {
	Success bool `json:"success"`
	Data    []struct {
		CoCode                 float64 `json:"co_code"`
		Yrc                    int     `json:"yrc"`
		Slno                   float64 `json:"slno"`
		Type                   string  `json:"type"`
		Name                   string  `json:"name"`
		PercentageStakeHolding float64 `json:"PercentageStakeHolding"`
	} `json:"data"`
	Message string `json:"message"`
}

type AutoGenerated struct {
	Success bool `json:"success"`
	Data    []struct {
		SchName   string  `json:"sch_Name"`
		MfSchCode float64 `json:"Mf_SchCode"`
		InvDate   string  `json:"InvDate"`
		MktValue  float64 `json:"MktValue"`
		CoCode    float64 `json:"Co_Code"`
		CoName    string  `json:"Co_Name"`
		PercHold  float64 `json:"Perc_Hold"`
		TOTNAV    float64 `json:"TOTNAV"`
		NoShares  float64 `json:"no_shares"`
	} `json:"data"`
	Message string `json:"message"`
}

var log_file, _ = os.Create("api_results.log")

func main() {

	router := gin.Default()
	router.GET("/get_caashflow_results", cashflow_master_generator)
	router.GET("/get_pnl", get_pnl)
	router.GET("/get_balance_sheet", get_balance_sheet)
	router.GET("/get_share_holding_pattern", get_share_holding_pattern)
	router.GET("/get_mutualfunds_holdings", get_mutualfunds_holdings)
	router.Run("0.0.0.0:8089")

}

func cashflow_master_generator(c *gin.Context) {
	co_code, _ := c.GetQuery("co_code")
	var cash_flow_quaterly cashflow_quaterly_master
	log.SetOutput(log_file)

	url := fmt.Sprintf("http://jwttoken.cmots.com/AlertTrade/api/QuarterlyResults/%s/S/", co_code)
	fmt.Println(url)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println(err)
	}
	req.Header.Set("Authorization", "Bearer "+api_key)

	res, err := http.DefaultClient.Do(req)

	if err != nil {
		log.Println(err)
	}

	res_body, err := io.ReadAll(res.Body)
	if err != nil {
		log.Println(err)
	}

	// fmt.Println(string(res_body))
	json.Unmarshal(res_body, &cash_flow_quaterly)

	c.IndentedJSON(http.StatusOK, cash_flow_quaterly)

}
func get_pnl(c *gin.Context) {
	co_code, _ := c.GetQuery("co_code")
	log.SetOutput(log_file)
	var pnl_obj pnl_struct

	url := fmt.Sprintf("http://jwttoken.cmots.com/AlertTrade/api/ProftandLoss/%s/S/", co_code)
	fmt.Println(url)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println(err)
	}
	req.Header.Set("Authorization", "Bearer "+api_key)

	res, err := http.DefaultClient.Do(req)

	if err != nil {
		log.Println(err)
	}

	res_body, err := io.ReadAll(res.Body)
	if err != nil {
		log.Println(err)
	}

	json.Unmarshal(res_body, &pnl_obj)

	fmt.Println(pnl_obj)

	c.IndentedJSON(http.StatusOK, pnl_obj)

}

func get_balance_sheet(c *gin.Context) {
	co_code, _ := c.GetQuery("co_code")
	log.SetOutput(log_file)
	var Balancesheet_struct Balancesheet
	url := fmt.Sprintf("http://jwttoken.cmots.com/AlertTrade/api/Balancesheet/%s/S/", co_code)
	fmt.Println(url)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println(err)
	}
	req.Header.Set("Authorization", "Bearer "+api_key)

	res, err := http.DefaultClient.Do(req)

	if err != nil {
		log.Println(err)
	}

	res_body, err := io.ReadAll(res.Body)
	if err != nil {
		log.Println(err)
	}
	// fmt.Println(string(res_body))
	json.Unmarshal(res_body, &Balancesheet_struct)

	// fmt.Println(Balancesheet_struct)

	c.IndentedJSON(http.StatusOK, Balancesheet_struct)

}

func get_share_holding_pattern(c *gin.Context) {
	co_code, _ := c.GetQuery("co_code")
	log.SetOutput(log_file)
	var shareholding_struct shareholding
	url := fmt.Sprintf("http://jwttoken.cmots.com/AlertTrade/api/ShareholdingMorethanonePerDetails/%s", co_code)
	fmt.Println(url)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println(err)
	}
	req.Header.Set("Authorization", "Bearer "+api_key)

	res, err := http.DefaultClient.Do(req)

	if err != nil {
		log.Println(err)
	}

	res_body, err := io.ReadAll(res.Body)
	if err != nil {
		log.Println(err)
	}

	json.Unmarshal(res_body, &shareholding_struct)

	c.IndentedJSON(http.StatusOK, shareholding_struct)

}

func get_mutualfunds_holdings(c *gin.Context) {
	var res_mf AutoGenerated
	cocode, _ := c.GetQuery("co_code")
	url := fmt.Sprintf("http://jwttoken.cmots.com/AlertTrade/api/CompanyWiseMFHolding/%s/100", cocode)

	log.SetOutput(log_file)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println(err)
	}
	req.Header.Set("Authorization", "Bearer "+api_key)
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Println(err)
	}
	res_body, err := io.ReadAll(res.Body)
	if err != nil {
		log.Println(err)
	}
	// fmt.Println(string(res_body))
	json.Unmarshal(res_body, &res_mf)
	c.IndentedJSON(http.StatusOK, res_mf)
}
